name: Build Single Images

on:
  # Ejecutar cada semana (domingos a las 00:00 UTC) - construye todo
  schedule:
    - cron: '0 0 * * 0'
  
  # Ejecutar cuando hay cambios en components
  push:
    branches:
      - main
    paths:
      - 'components/**'
  
  # Permitir ejecución manual con opción de forzar todo
  workflow_dispatch:
    inputs:
      build_all:
        description: 'Construir todas las imágenes (ignorar cambios)'
        required: false
        default: false
        type: boolean

jobs:
  discover:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Necesario para comparar commits

      - name: Detect changed components
        id: set-matrix
        run: |
          images=()
          
          # Determinar si construir todo o solo cambios
          BUILD_ALL="${{ github.event.inputs.build_all || 'false' }}"
          
          # En schedule siempre construir todo
          if [ "${{ github.event_name }}" == "schedule" ]; then
            BUILD_ALL="true"
          fi
          
          echo "Build all: $BUILD_ALL"
          
          # Obtener archivos cambiados (solo en push)
          if [ "$BUILD_ALL" == "false" ] && [ "${{ github.event_name }}" == "push" ]; then
            # Comparar con el commit anterior
            CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} 2>/dev/null || git diff --name-only HEAD~1 HEAD)
            echo "Changed files:"
            echo "$CHANGED_FILES"
          else
            CHANGED_FILES=""
          fi
          
          # Función para verificar si un componente tiene cambios
          has_changes() {
            local component_path="$1"
            if [ "$BUILD_ALL" == "true" ] || [ -z "$CHANGED_FILES" ]; then
              return 0  # Construir
            fi
            echo "$CHANGED_FILES" | grep -q "^${component_path}" && return 0 || return 1
          }
          
          # 1. Buscar install.sh para versiones latest
          for install_script in components/*/install.sh; do
            if [ -f "$install_script" ]; then
              component=$(basename $(dirname "$install_script"))
              component_path="components/$component/"
              
              if has_changes "$component_path"; then
                echo "✓ Build latest: $component (changed)"
                images+=("{\"component\":\"$component\",\"version\":\"latest\",\"type\":\"install\"}")
              else
                echo "✗ Skip latest: $component (no changes)"
              fi
            fi
          done
          
          # 2. Buscar Dockerfiles en subcarpetas para versiones legacy
          for dockerfile in components/*/*/Dockerfile; do
            if [ -f "$dockerfile" ]; then
              path=$(dirname "$dockerfile")
              version=$(basename "$path")
              component=$(basename $(dirname "$path"))
              component_path="components/$component/$version/"
              
              if has_changes "$component_path"; then
                echo "✓ Build legacy: $component:$version (changed)"
                images+=("{\"component\":\"$component\",\"version\":\"$version\",\"type\":\"dockerfile\"}")
              else
                echo "✗ Skip legacy: $component:$version (no changes)"
              fi
            fi
          done
          
          # Construir JSON matrix
          if [ ${#images[@]} -eq 0 ]; then
            echo "No components to build"
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
          else
            matrix=$(printf '%s,' "${images[@]}" | sed 's/,$//')
            echo "matrix={\"include\":[$matrix]}" >> $GITHUB_OUTPUT
            echo ""
            echo "Components to build: ${#images[@]}"
          fi

  build:
    needs: discover
    if: ${{ fromJson(needs.discover.outputs.matrix).include[0] != null }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 10
      matrix: ${{ fromJson(needs.discover.outputs.matrix) }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: toolkitbox
          password: ${{ secrets.DOCKER_TOKEN }}

      # Build para componentes con install.sh (latest)
      - name: Build and push ${{ matrix.component }}:latest
        if: matrix.type == 'install'
        run: |
          cat <<'EOF' | docker build -t "toolkitbox/${{ matrix.component }}:latest" -f - "components/${{ matrix.component }}"
          FROM alpine:latest
          RUN apk add --no-cache bash curl ca-certificates
          COPY install.sh /tmp/install.sh
          RUN chmod +x /tmp/install.sh && /tmp/install.sh && rm /tmp/install.sh
          WORKDIR /root
          CMD ["/bin/sh"]
          EOF
          docker push "toolkitbox/${{ matrix.component }}:latest"

      # Build para componentes legacy con Dockerfile
      - name: Build and push ${{ matrix.component }}:${{ matrix.version }}
        if: matrix.type == 'dockerfile'
        uses: docker/build-push-action@v6
        with:
          context: components/${{ matrix.component }}/${{ matrix.version }}
          file: components/${{ matrix.component }}/${{ matrix.version }}/Dockerfile
          push: true
          tags: toolkitbox/${{ matrix.component }}:${{ matrix.version }}
          cache-from: type=gha,scope=${{ matrix.component }}-${{ matrix.version }}
          cache-to: type=gha,mode=max,scope=${{ matrix.component }}-${{ matrix.version }}
